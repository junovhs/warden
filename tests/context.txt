ğŸ›¡ï¸ SYSTEM MANDATE: THE WARDEN PROTOCOL
ROLE: High-Integrity Systems Architect (NASA/JPL Standard).
CONTEXT: You are coding inside a strict environment enforced by Warden.

THE 3 LAWS (Non-Negotiable):

1. LAW OF ATOMICITY
   - Files: MUST be < 2000 tokens.
   - Action: Split immediately if larger.

2. LAW OF COMPLEXITY
   - Cyclomatic Complexity: MUST be â‰¤ 8 per function.
   - Nesting Depth: MUST be â‰¤ 3 levels.
   - Function Arguments: MUST be â‰¤ 5 parameters.

3. LAW OF PARANOIA
   - Use Result<T, E> for I/O and fallible operations.
   - NO .unwrap() or .expect() calls.

OUTPUT FORMAT (MANDATORY):

1. Explain the changes (Technical Plan) using NABLA PROTOCOL:
   - Must start with "GOAL:"
   - Must include "CHANGES:" list

âˆ‡âˆ‡âˆ‡ PLAN âˆ‡âˆ‡âˆ‡
GOAL: Refactor authentication module.
CHANGES:
1. Extract user validation to new file.
2. Update config parser.
âˆ†âˆ†âˆ†

2. Declare the plan (Manifest) using NABLA PROTOCOL:

âˆ‡âˆ‡âˆ‡ MANIFEST âˆ‡âˆ‡âˆ‡
path/to/file1.rs
path/to/file2.rs [NEW]
âˆ†âˆ†âˆ†

3. Provide EACH file using NABLA PROTOCOL:

âˆ‡âˆ‡âˆ‡ path/to/file1.rs âˆ‡âˆ‡âˆ‡
[file content]
âˆ†âˆ†âˆ†

RULES:
- Do NOT use markdown code blocks (e.g. triple backticks) to wrap the file. The âˆ‡âˆ‡âˆ‡ delimiters ARE the fence.
- You MAY use markdown inside the file content.
- Every file in the manifest MUST have a matching âˆ‡âˆ‡âˆ‡ block.
- Paths must match exactly.
- Do NOT truncate files (No "// ...").


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BEGIN CODEBASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸  ACTIVE VIOLATIONS (PRIORITY FIX REQUIRED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FILE: cli_exit.rs
LAW:  LAW OF BLUNTNESS
LINE: 48
ERR:  Function 'test_exit_0_empty_file_list' has 6 words (Max: 5). Is it doing too much?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_exit.rs
LAW:  LAW OF PARANOIA
LINE: 8
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_exit.rs
LAW:  LAW OF PARANOIA
LINE: 9
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_exit.rs
LAW:  LAW OF PARANOIA
LINE: 22
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_exit.rs
LAW:  LAW OF PARANOIA
LINE: 31
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 20
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 22
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 23
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 36
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 38
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 39
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 40
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 46
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 48
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 49
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 50
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 51
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 72
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 78
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_hooks.rs
LAW:  LAW OF PARANOIA
LINE: 80
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_roadmap.rs
LAW:  LAW OF PARANOIA
LINE: 7
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: cli_roadmap.rs
LAW:  LAW OF PARANOIA
LINE: 9
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_apply.rs
LAW:  LAW OF PARANOIA
LINE: 10
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_apply.rs
LAW:  LAW OF PARANOIA
LINE: 18
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_apply.rs
LAW:  LAW OF PARANOIA
LINE: 25
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_apply.rs
LAW:  LAW OF PARANOIA
LINE: 135
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_backup.rs
LAW:  LAW OF PARANOIA
LINE: 6
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_backup.rs
LAW:  LAW OF PARANOIA
LINE: 8
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_backup.rs
LAW:  LAW OF PARANOIA
LINE: 14
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_backup.rs
LAW:  LAW OF PARANOIA
LINE: 15
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_backup.rs
LAW:  LAW OF PARANOIA
LINE: 18
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 9
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 10
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 11
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 12
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 27
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 32
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 41
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 49
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 57
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 65
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 73
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 78
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 86
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 87
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_pack.rs
LAW:  LAW OF PARANOIA
LINE: 96
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: integration_roadmap.rs
LAW:  LAW OF BLUNTNESS
LINE: 59
ERR:  Function 'test_parse_extracts_from_larger_text' has 6 words (Max: 5). Is it doing too much?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: protection_roadmap.rs
LAW:  LAW OF BLUNTNESS
LINE: 41
ERR:  Function 'test_roadmap_rewrite_blocked_case_insensitive' has 6 words (Max: 5). Is it doing too much?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 49
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 67
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 72
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 72
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 73
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 93
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 97
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 97
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_audit.rs
LAW:  LAW OF PARANOIA
LINE: 98
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_config.rs
LAW:  LAW OF PARANOIA
LINE: 40
ERR:  Banned: '.expect()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_config.rs
LAW:  LAW OF PARANOIA
LINE: 54
ERR:  Banned: '.expect()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_diff.rs
LAW:  LAW OF ATOMICITY
LINE: 1
ERR:  File size is 2329 tokens (Limit: 2000)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_diff.rs
LAW:  LAW OF BLUNTNESS
LINE: 303
ERR:  Function 'test_combined_update_and_status_change' has 6 words (Max: 5). Is it doing too much?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_extractor.rs
LAW:  LAW OF PARANOIA
LINE: 13
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 7
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 14
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 14
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 21
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 21
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 28
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_manifest.rs
LAW:  LAW OF PARANOIA
LINE: 28
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_parser.rs
LAW:  LAW OF BLUNTNESS
LINE: 136
ERR:  Function 'test_anchor_extracts_function_name_only' has 6 words (Max: 5). Is it doing too much?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_parser.rs
LAW:  LAW OF BLUNTNESS
LINE: 180
ERR:  Function 'test_no_test_marker_uses_text_id' has 7 words (Max: 5). Is it doing too much?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 8
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 9
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 15
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 16
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 22
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 23
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 29
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 30
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_project.rs
LAW:  LAW OF PARANOIA
LINE: 36
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 6
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 8
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 8
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 9
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 15
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 17
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 23
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 25
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FILE: unit_writer.rs
LAW:  LAW OF PARANOIA
LINE: 26
ERR:  Banned: '.unwrap()'. Use '?' or 'unwrap_or'.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âˆ‡âˆ‡âˆ‡ warden.toml âˆ‡âˆ‡âˆ‡
# warden.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 8
max_nesting_depth = 3
max_function_args = 5
max_function_words = 5
ignore_naming_on = ["tests", "spec"]

# No project type detected. Configure commands manually:
# [commands]
# check = "your-lint-command"
# fix = "your-fix-command"

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ cli_exit.rs âˆ‡âˆ‡âˆ‡
// tests/cli_exit.rs - Exit code tests
use warden_core::config::Config;
use warden_core::analysis::RuleEngine;
use std::fs;
use tempfile::TempDir;

fn temp() -> TempDir {
    let d = tempfile::tempdir().unwrap();
    fs::create_dir_all(d.path().join("src")).unwrap();
    d
}

fn cfg() -> Config {
    let mut c = Config::new();
    c.rules.max_file_tokens = 100;
    c
}

#[test]
fn test_exit_0_clean() {
    let d = temp();
    fs::write(d.path().join("src/a.rs"), "fn main() {}").unwrap();
    let engine = RuleEngine::new(cfg());
    let report = engine.scan(vec![d.path().join("src/a.rs")]);
    assert_eq!(report.total_violations, 0);
}

#[test]
fn test_exit_1_violations() {
    let d = temp();
    fs::write(d.path().join("src/a.rs"), "fn f() { Some(1).unwrap(); }").unwrap();
    let engine = RuleEngine::new(cfg());
    let report = engine.scan(vec![d.path().join("src/a.rs")]);
    assert!(report.total_violations > 0);
}

#[test]
fn test_exit_codes_distinct() {
    let clean = 0;
    let violations = 1;
    let error = 2;
    assert_ne!(clean, violations);
    assert_ne!(violations, error);
    assert_ne!(clean, error);
}

#[test]
fn test_exit_0_empty_file_list() {
    let engine = RuleEngine::new(cfg());
    let report = engine.scan(vec![]);
    assert_eq!(report.total_violations, 0);
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ cli_format.rs âˆ‡âˆ‡âˆ‡
// tests/cli_format.rs

#[test]
fn test_json_output_structure() {
    let json = r#"{"total_files":1,"total_violations":0}"#;
    assert!(json.starts_with('{'));
    assert!(json.ends_with('}'));
}

#[test]
fn test_json_includes_paths() {
    let json = r#"{"files":[{"path":"src/main.rs"}]}"#;
    assert!(json.contains("path"));
}

#[test]
fn test_sarif_output_structure() {
    let sarif = r#"{"$schema":"sarif","version":"2.1.0"}"#;
    assert!(sarif.contains("2.1.0"));
}

#[test]
fn test_sarif_includes_tool_info() {
    let sarif = r#"{"tool":{"driver":{"name":"warden"}}}"#;
    assert!(sarif.contains("warden"));
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ cli_hooks.rs âˆ‡âˆ‡âˆ‡
// tests/cli_hooks.rs
use std::fs;

fn hook_content() -> &'static str {
    r"#!/bin/sh
echo 'Warden: Running pre-commit checks...'
warden check
RESULT=$?
if [ $RESULT -ne 0 ]; then
    echo 'Warden found violations. Commit blocked.'
    exit 1
fi
echo 'Warden: All checks passed!'
exit 0
"
}

#[test]
fn test_hook_install() {
    let d = tempfile::tempdir().unwrap();
    let hooks = d.path().join(".git/hooks");
    fs::create_dir_all(&hooks).unwrap();
    fs::write(hooks.join("pre-commit"), hook_content()).unwrap();
    assert!(hooks.join("pre-commit").exists());
}

#[test]
fn test_hook_has_shebang() {
    assert!(hook_content().starts_with("#!/bin/sh"));
}

#[test]
#[cfg(unix)]
fn test_hook_is_executable() {
    use std::os::unix::fs::PermissionsExt;
    let d = tempfile::tempdir().unwrap();
    let p = d.path().join("hook");
    fs::write(&p, hook_content()).unwrap();
    fs::set_permissions(&p, fs::Permissions::from_mode(0o755)).unwrap();
    let mode = fs::metadata(&p).unwrap().permissions().mode();
    assert!(mode & 0o111 != 0);
}

#[test]
fn test_hook_backs_up_existing() {
    let d = tempfile::tempdir().unwrap();
    let hooks = d.path().join(".git/hooks");
    fs::create_dir_all(&hooks).unwrap();
    fs::write(hooks.join("pre-commit"), "old").unwrap();
    fs::write(hooks.join("pre-commit.warden-backup"), "old").unwrap();
    fs::write(hooks.join("pre-commit"), hook_content()).unwrap();
    assert!(hooks.join("pre-commit.warden-backup").exists());
}

#[test]
fn test_precommit_runs() {
    assert!(hook_content().contains("warden"));
}

#[test]
fn test_hook_exits_on_violations() {
    assert!(hook_content().contains("exit"));
}

#[test]
fn test_hook_provides_feedback() {
    assert!(hook_content().contains("echo"));
}

#[test]
fn test_no_git_directory() {
    let d = tempfile::tempdir().unwrap();
    assert!(!d.path().join(".git").exists());
}

#[test]
fn test_creates_hooks_dir() {
    let d = tempfile::tempdir().unwrap();
    let hooks = d.path().join(".git/hooks");
    fs::create_dir_all(&hooks).unwrap();
    assert!(hooks.exists());
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ cli_roadmap.rs âˆ‡âˆ‡âˆ‡
// tests/cli_roadmap.rs
use std::fs;
use warden_core::roadmap::Roadmap;

#[test]
fn test_init_creates_file() {
    let d = tempfile::tempdir().unwrap();
    let p = d.path().join("ROADMAP.md");
    fs::write(&p, "# Test\n\n## v0.1.0\n").unwrap();
    assert!(p.exists());
}

#[test]
fn test_prompt_generates() {
    let r = Roadmap::parse("# Test\n\n## v0.1.0\n\n- [ ] Task\n");
    let opts = warden_core::roadmap::PromptOptions::default();
    let p = warden_core::roadmap::generate_prompt(&r, &opts);
    assert!(!p.is_empty());
}

#[test] fn test_apply_from_clipboard() {}
#[test] fn test_show_tree() {}
#[test] fn test_tasks_list() {}
#[test] fn test_tasks_pending_filter() {}
#[test] fn test_tasks_complete_filter() {}
#[test] fn test_audit_runs() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_apply.rs âˆ‡âˆ‡âˆ‡
// tests/integration_apply.rs
use std::collections::HashMap;
use warden_core::apply::extractor;
use warden_core::apply::types::{ApplyOutcome, FileContent};
use warden_core::apply::validator;

#[test]
fn test_extract_single_file() {
    let input = "âˆ‡âˆ‡âˆ‡ src/main.rs âˆ‡âˆ‡âˆ‡\nfn main() {}\nâˆ†âˆ†âˆ†";
    let files = extractor::extract_files(input).unwrap();
    assert_eq!(files.len(), 1);
    assert!(files.contains_key("src/main.rs"));
}

#[test]
fn test_extract_multiple_files() {
    let input = "âˆ‡âˆ‡âˆ‡ a.rs âˆ‡âˆ‡âˆ‡\nfn a(){}\nâˆ†âˆ†âˆ†\nâˆ‡âˆ‡âˆ‡ b.rs âˆ‡âˆ‡âˆ‡\nfn b(){}\nâˆ†âˆ†âˆ†";
    let files = extractor::extract_files(input).unwrap();
    assert_eq!(files.len(), 2);
}

#[test]
fn test_extract_skips_manifest() {
    let input = "âˆ‡âˆ‡âˆ‡ MANIFEST âˆ‡âˆ‡âˆ‡\na.rs\nâˆ†âˆ†âˆ†\nâˆ‡âˆ‡âˆ‡ a.rs âˆ‡âˆ‡âˆ‡\nfn a(){}\nâˆ†âˆ†âˆ†";
    let files = extractor::extract_files(input).unwrap();
    assert_eq!(files.len(), 1);
    assert!(!files.contains_key("MANIFEST"));
}

#[test]
fn test_extract_plan() {
    let input = "âˆ‡âˆ‡âˆ‡ PLAN âˆ‡âˆ‡âˆ‡\nGOAL: Test\nâˆ†âˆ†âˆ†";
    let plan = extractor::extract_plan(input);
    assert!(plan.is_some());
    assert!(plan.unwrap().contains("GOAL"));
}

#[test]
fn test_path_safety_blocks_traversal() {
    let mut files = HashMap::new();
    files.insert("../etc/passwd".into(), FileContent { content: "x".into(), line_count: 1 });
    let r = validator::validate(&vec![], &files);
    if let ApplyOutcome::ValidationFailure { errors, .. } = r {
        assert!(errors.iter().any(|e| e.contains("SECURITY") || e.contains("traversal")));
    } else {
        panic!("Should fail");
    }
}

#[test]
fn test_path_safety_blocks_absolute() {
    let mut files = HashMap::new();
    files.insert("/etc/passwd".into(), FileContent { content: "x".into(), line_count: 1 });
    let r = validator::validate(&vec![], &files);
    if let ApplyOutcome::ValidationFailure { errors, .. } = r {
        assert!(errors.iter().any(|e| e.contains("SECURITY") || e.contains("absolute")));
    } else {
        panic!("Should fail");
    }
}

#[test]
fn test_path_safety_blocks_git() {
    let mut files = HashMap::new();
    files.insert(".git/config".into(), FileContent { content: "x".into(), line_count: 1 });
    let r = validator::validate(&vec![], &files);
    assert!(matches!(r, ApplyOutcome::ValidationFailure { .. }));
}

#[test]
fn test_path_safety_blocks_hidden() {
    let mut files = HashMap::new();
    files.insert(".secret".into(), FileContent { content: "x".into(), line_count: 1 });
    let r = validator::validate(&vec![], &files);
    assert!(matches!(r, ApplyOutcome::ValidationFailure { .. }));
}

#[test]
fn test_truncation_detects_ellipsis_comment() {
    let mut files = HashMap::new();
    files.insert("a.rs".into(), FileContent { content: "fn f() {\n// ...\n}".into(), line_count: 3 });
    let r = validator::validate(&vec![], &files);
    if let ApplyOutcome::ValidationFailure { errors, .. } = r {
        assert!(errors.iter().any(|e| e.contains("truncation") || e.contains("...")));
    } else {
        panic!("Should fail");
    }
}

#[test]
fn test_truncation_allows_warden_ignore() {
    let mut files = HashMap::new();
    files.insert("a.rs".into(), FileContent { content: "fn f() {\n// ... warden:ignore\n}".into(), line_count: 3 });
    let r = validator::validate(&vec![], &files);
    if let ApplyOutcome::ValidationFailure { errors, .. } = r {
        let trunc: Vec<_> = errors.iter().filter(|e| e.contains("truncation")).collect();
        assert!(trunc.is_empty(), "warden:ignore should bypass");
    }
}

#[test]
fn test_truncation_detects_empty_file() {
    let mut files = HashMap::new();
    files.insert("a.rs".into(), FileContent { content: String::new(), line_count: 0 });
    let r = validator::validate(&vec![], &files);
    if let ApplyOutcome::ValidationFailure { errors, .. } = r {
        assert!(errors.iter().any(|e| e.contains("empty")));
    } else {
        panic!("Should fail");
    }
}

#[test]
fn test_path_safety_allows_valid() {
    let mut files = HashMap::new();
    files.insert("src/main.rs".into(), FileContent { content: "fn main() {}".into(), line_count: 1 });
    let r = validator::validate(&vec![], &files);
    if let ApplyOutcome::Success { written, .. } = r {
        assert!(written.contains(&"src/main.rs".to_string()));
    } else if let ApplyOutcome::ValidationFailure { errors, .. } = r {
        panic!("Should pass: {errors:?}");
    }
}

#[test]
fn test_unified_apply_roadmap() {
    let input = "===ROADMAP===\nCHECK task\n===END===";
    assert!(input.contains("===ROADMAP==="));
}

#[test]
fn test_unified_apply_combined() {
    let input = "===ROADMAP===\nCHECK task\n===END===\nâˆ‡âˆ‡âˆ‡ a.rs âˆ‡âˆ‡âˆ‡\nfn a(){}\nâˆ†âˆ†âˆ†";
    assert!(input.contains("===ROADMAP==="));
    let files = extractor::extract_files(input).unwrap();
    assert!(files.contains_key("a.rs"));
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_audit.rs âˆ‡âˆ‡âˆ‡
// tests/integration_audit.rs
use warden_core::roadmap::Roadmap;

#[test]
fn test_scans_completed_only() {
    let r = Roadmap::parse("# T\n\n## v0.1.0\n\n- [x] Done\n- [ ] Todo\n");
    let t = r.all_tasks();
    let complete: Vec<_> = t.iter().filter(|t| t.status == warden_core::roadmap::TaskStatus::Complete).collect();
    assert!(!complete.is_empty());
}

#[test] fn test_no_test_skipped() {}
#[test] fn test_explicit_anchor_verified() {}
#[test] fn test_missing_file_detected() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_backup.rs âˆ‡âˆ‡âˆ‡
// tests/integration_backup.rs
use std::fs;

#[test]
fn test_backup_dir_created() {
    let d = tempfile::tempdir().unwrap();
    let backup = d.path().join(".warden_apply_backup");
    fs::create_dir_all(&backup).unwrap();
    assert!(backup.exists());
}

#[test]
fn test_timestamp_folder() {
    let d = tempfile::tempdir().unwrap();
    let ts = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH).unwrap().as_secs();
    let backup = d.path().join(format!(".warden_apply_backup/{ts}"));
    fs::create_dir_all(&backup).unwrap();
    assert!(backup.exists());
}

#[test] fn test_existing_backed_up() {}
#[test] fn test_new_file_no_backup() {}
#[test] fn test_path_structure() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_core.rs âˆ‡âˆ‡âˆ‡
// tests/integration_core.rs
//! Integration tests for the 3 Laws enforcement.
//!
//! VERIFICATION STRATEGY:
//! 1. Isolation: Each syntactic construct (if, match, loop) is tested separately.
//! 2. Boundaries: Tests verify behavior exactly at the limit and limit + 1.
//! 3. Safety: Tests verify that safe alternatives do not trigger violations.

use anyhow::Result;
use std::fs::File;
use std::io::Write;
use tempfile::TempDir;
use warden_core::analysis::RuleEngine;
use warden_core::config::{Config, RuleConfig};
use warden_core::types::Violation;

// --- Helpers ---

fn config_complexity(limit: usize) -> RuleConfig {
    RuleConfig {
        max_cyclomatic_complexity: limit,
        ..Default::default()
    }
}

fn config_depth(limit: usize) -> RuleConfig {
    RuleConfig {
        max_nesting_depth: limit,
        ..Default::default()
    }
}

fn config_arity(limit: usize) -> RuleConfig {
    RuleConfig {
        max_function_args: limit,
        ..Default::default()
    }
}

fn config_tokens(limit: usize) -> RuleConfig {
    RuleConfig {
        max_file_tokens: limit,
        ..Default::default()
    }
}

fn scan(content: &str, rules: RuleConfig) -> Result<Vec<Violation>> {
    let dir = TempDir::new()?;
    let file_path = dir.path().join("test.rs");
    let mut file = File::create(&file_path)?;
    write!(file, "{content}")?;

    let mut config = Config::new();
    config.rules = rules;

    let engine = RuleEngine::new(config);
    let report = engine.scan(vec![file_path]);

    Ok(report
        .files
        .into_iter()
        .flat_map(|f| f.violations)
        .collect())
}

// --- Law of Atomicity ---

#[test]
fn test_atomicity_clean_file_passes() -> Result<()> {
    let content = r#"fn main() { println!("Small file"); }"#;
    // Limit is 100, content is ~10 tokens
    let violations = scan(content, config_tokens(100))?;
    assert!(violations.is_empty());
    Ok(())
}

#[test]
fn test_atomicity_large_file_fails() -> Result<()> {
    // Generate content definitely larger than limit
    let content = "fn main() { let x = 1; } ".repeat(20);
    // Limit is 10 tokens
    let violations = scan(&content, config_tokens(10))?;

    assert!(!violations.is_empty());
    assert!(violations[0].message.contains("File size"));
    Ok(())
}

// --- Law of Complexity: Granular Verification ---

#[test]
fn test_complexity_boundary_check() -> Result<()> {
    // Base complexity of a function is 1.
    // Adding one 'if' adds 1.
    // Total = 2.
    let content = "fn f() { if true {} }";

    // Case 1: Limit = 2 (Should Pass)
    let violations = scan(content, config_complexity(2))?;
    assert!(
        violations.is_empty(),
        "Complexity 2 should pass limit 2"
    );

    // Case 2: Limit = 1 (Should Fail)
    let violations = scan(content, config_complexity(1))?;
    assert!(
        violations.iter().any(|v| v.message.contains("Score is 2")),
        "Complexity 2 should fail limit 1"
    );
    Ok(())
}

#[test]
fn test_complexity_construct_match() -> Result<()> {
    // Matches count as branches.
    // Base(1) + Arm(1) + Arm(1) = 3
    let content = r"
        fn f(x: i32) {
            match x {
                1 => {},
                2 => {},
                _ => {}
            }
        }
    ";
    let violations = scan(content, config_complexity(2))?;
    assert!(
        violations.iter().any(|v| v.message.contains("High Complexity")),
        "Match arms must increment complexity"
    );
    Ok(())
}

#[test]
fn test_complexity_construct_loops() -> Result<()> {
    // Loops count as branches.
    // Base(1) + For(1) + While(1) = 3
    let content = r"
        fn f() {
            for _ in 0..10 {}
            while true {}
        }
    ";
    let violations = scan(content, config_complexity(2))?;
    assert!(
        violations.iter().any(|v| v.message.contains("High Complexity")),
        "Loops must increment complexity"
    );
    Ok(())
}

#[test]
fn test_complexity_construct_logic_ops() -> Result<()> {
    // Boolean operators count as branches (short-circuiting).
    // Base(1) + &&(1) + ||(1) = 3
    let content = "fn f(a: bool, b: bool, c: bool) { if a && b || c {} }";
    
    // Note: The 'if' itself counts (1), plus && (1), plus || (1).
    // Total for this function: Base(1) + If(1) + &&(1) + ||(1) = 4.
    
    let violations = scan(content, config_complexity(3))?;
    assert!(
        violations.iter().any(|v| v.message.contains("High Complexity")),
        "Logic operators (&&, ||) must increment complexity"
    );
    Ok(())
}

// --- Law of Complexity: Nesting ---

#[test]
fn test_nesting_boundary() -> Result<()> {
    // Depth: Function block (0) -> If (1).
    let content = "fn f() { if true {} }";

    // Limit 1: Pass
    assert!(scan(content, config_depth(1))?.is_empty());

    // Limit 0: Fail
    // The engine treats function body as depth 0, first block as 1.
    // Let's verify depth 2 fails limit 1.
    let deep = "fn f() { if true { if true {} } }"; // Depth 2
    
    assert!(scan(deep, config_depth(2))?.is_empty());
    
    let violations = scan(deep, config_depth(1))?;
    assert!(
        violations.iter().any(|v| v.message.contains("Deep Nesting")),
        "Depth 2 should fail limit 1"
    );
    Ok(())
}

// --- Law of Complexity: Arity ---

#[test]
fn test_arity_boundary() -> Result<()> {
    let content = "fn f(a: i32, b: i32) {}";

    // Limit 2: Pass
    assert!(scan(content, config_arity(2))?.is_empty());

    // Limit 1: Fail
    let violations = scan(content, config_arity(1))?;
    assert!(
        violations.iter().any(|v| v.message.contains("High Arity")),
        "2 Args should fail limit 1"
    );
    Ok(())
}

// --- Law of Paranoia ---

#[test]
fn test_paranoia_unwrap_fails() -> Result<()> {
    let content = "fn risky() { let x = Some(1); x.unwrap(); }";
    let violations = scan(content, RuleConfig::default())?;

    assert!(violations
        .iter()
        .any(|v| v.message.contains("Banned: '.unwrap()'")));
    Ok(())
}

#[test]
fn test_paranoia_expect_fails() -> Result<()> {
    let content = r#"fn risky() { let x = Some(1); x.expect("boom"); }"#;
    let violations = scan(content, RuleConfig::default())?;

    assert!(violations
        .iter()
        .any(|v| v.message.contains("Banned: '.expect()'")));
    Ok(())
}

#[test]
fn test_paranoia_safe_alternatives_pass() -> Result<()> {
    // Ensure we don't flag valid alternatives or other methods
    // We use r#...# to allow quotes inside the string.
    let content = r#"
        fn safe() { 
            let x = Some(1); 
            x.unwrap_or(0);
            x.unwrap_or_else(|| 0);
            // Result operator should be fine
            let _ = File::open("foo")?; 
        }
    "#;
    let violations = scan(content, RuleConfig::default())?;
    assert!(violations.is_empty(), "Safe error handling should not trigger violations");
    Ok(())
}

// --- Ignore Mechanics ---

#[test]
fn test_warden_ignore_skips_file() -> Result<()> {
    let content = r"
        // warden:ignore
        fn extremely_complex_and_bad(a:i32,b:i32,c:i32,d:i32,e:i32) {
             if true { if true { if true { x.unwrap(); } } }
        }
    ";
    let violations = scan(content, config_complexity(1))?;
    assert!(violations.is_empty(), "warden:ignore should bypass all checks");
    Ok(())
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_pack.rs âˆ‡âˆ‡âˆ‡
// tests/integration_pack.rs
use std::fs;
use tempfile::TempDir;
use warden_core::config::Config;
use warden_core::pack::{self, PackOptions};
use warden_core::prompt::PromptGenerator;

fn temp() -> TempDir {
    let d = tempfile::tempdir().unwrap();
    fs::write(d.path().join("Cargo.toml"), "[package]").unwrap();
    fs::create_dir_all(d.path().join("src")).unwrap();
    fs::write(d.path().join("src/main.rs"), "fn main() {}").unwrap();
    d
}

#[test]
fn test_nabla_delimiters_are_unique() {
    // Verify âˆ‡âˆ‡âˆ‡ and âˆ†âˆ†âˆ† don't appear in normal code
    let code = "fn main() { let x = 1; }";
    assert!(!code.contains("âˆ‡âˆ‡âˆ‡"));
    assert!(!code.contains("âˆ†âˆ†âˆ†"));
}

#[test]
fn test_nabla_format_structure() {
    let d = temp();
    std::env::set_current_dir(d.path()).unwrap();
    let opts = PackOptions { prompt: false, ..Default::default() };
    let mut cfg = Config::new();
    cfg.load_local_config();
    let files = vec![d.path().join("src/main.rs")];
    let content = pack::generate_content(&files, &opts, &cfg).unwrap();
    assert!(content.contains("âˆ‡âˆ‡âˆ‡"));
    assert!(content.contains("âˆ†âˆ†âˆ†"));
}

#[test]
fn test_prompt_includes_laws() {
    let cfg = Config::new();
    let gen = PromptGenerator::new(cfg.rules.clone());
    let prompt = gen.generate().unwrap();
    assert!(prompt.contains("LAW") || prompt.contains("Law"));
}

#[test]
fn test_prompt_includes_limits() {
    let cfg = Config::new();
    let gen = PromptGenerator::new(cfg.rules.clone());
    let prompt = gen.generate().unwrap();
    assert!(prompt.contains("2000") || prompt.contains("token"));
}

#[test]
fn test_prompt_includes_nabla_instructions() {
    let cfg = Config::new();
    let gen = PromptGenerator::new(cfg.rules.clone());
    let prompt = gen.generate().unwrap();
    assert!(prompt.contains("âˆ‡âˆ‡âˆ‡") || prompt.contains("Nabla") || prompt.contains("NABLA"));
}

#[test]
fn test_reminder_is_concise() {
    let cfg = Config::new();
    let gen = PromptGenerator::new(cfg.rules.clone());
    let reminder = gen.generate_reminder().unwrap();
    let lines: Vec<_> = reminder.lines().collect();
    assert!(lines.len() < 500);
}

#[test]
fn test_pack_skeleton_integration() {
    let d = temp();
    std::env::set_current_dir(d.path()).unwrap();
    let opts = PackOptions { skeleton: true, prompt: false, ..Default::default() };
    let mut cfg = Config::new();
    cfg.load_local_config();
    let files = vec![d.path().join("src/main.rs")];
    let content = pack::generate_content(&files, &opts, &cfg).unwrap();
    // Skeleton mode should produce { ... } or similar
    assert!(content.contains("...") || content.contains("main"));
}

#[test]
fn test_smart_context_focus_mode() {
    let d = temp();
    fs::write(d.path().join("src/other.rs"), "fn other() {}").unwrap();
    std::env::set_current_dir(d.path()).unwrap();
    let opts = PackOptions {
        target: Some(d.path().join("src/main.rs")),
        prompt: false,
        ..Default::default()
    };
    let mut cfg = Config::new();
    cfg.load_local_config();
    let files = vec![d.path().join("src/main.rs"), d.path().join("src/other.rs")];
    let content = pack::generate_content(&files, &opts, &cfg).unwrap();
    assert!(content.contains("main"));
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_roadmap.rs âˆ‡âˆ‡âˆ‡
// tests/integration_roadmap.rs
use warden_core::roadmap::{slugify, CommandBatch, Roadmap};

const SAMPLE: &str = "# Test\n\n## v0.1.0\n\n- [x] **Done**\n- [ ] **Todo**\n";

#[test]
fn test_parse_simple_roadmap() {
    let r = Roadmap::parse(SAMPLE);
    assert_eq!(r.title, "Test");
    assert!(!r.sections.is_empty());
}

#[test]
fn test_parse_extracts_tasks() {
    let r = Roadmap::parse(SAMPLE);
    let t = r.all_tasks();
    assert!(t.len() >= 2);
}

#[test]
fn test_stats_are_correct() {
    let r = Roadmap::parse(SAMPLE);
    let s = r.stats();
    assert_eq!(s.total, s.complete + s.pending);
}

#[test]
fn test_find_task_by_path() {
    let r = Roadmap::parse(SAMPLE);
    let t = r.all_tasks();
    if let Some(first) = t.first() {
        assert!(r.find_task(&first.path).is_some());
    }
}

#[test]
fn test_compact_state_format() {
    let r = Roadmap::parse(SAMPLE);
    let c = r.compact_state();
    assert!(c.contains("Test"));
}

#[test]
fn test_slugify_basic() {
    assert_eq!(slugify("Hello World"), "hello-world");
}

#[test]
fn test_slugify_special_chars() {
    assert_eq!(slugify("hello_world"), "hello-world");
}

#[test]
fn test_slugify_preserves_numbers() {
    assert_eq!(slugify("v0.1.0"), "v0-1-0");
}

#[test]
fn test_parse_extracts_from_larger_text() {
    let input = "text\n===ROADMAP===\nCHECK task\n===END===\nmore";
    let b = CommandBatch::parse(input);
    assert!(!b.commands.is_empty());
}

#[test]
fn test_parse_check_command() {
    let b = CommandBatch::parse("CHECK task-path");
    assert_eq!(b.commands.len(), 1);
}

#[test]
fn test_parse_multiple_commands() {
    let input = "CHECK a\nUNCHECK b\nADD v0.1.0 \"New\"";
    let b = CommandBatch::parse(input);
    assert_eq!(b.commands.len(), 3);
}

#[test]
fn test_parse_add_with_after() {
    let b = CommandBatch::parse("ADD v0.1.0 \"New\" AFTER existing");
    assert_eq!(b.commands.len(), 1);
}

#[test]
fn test_parse_ignores_comments() {
    let input = "# comment\nCHECK a\n// another\nCHECK b";
    let b = CommandBatch::parse(input);
    assert_eq!(b.commands.len(), 2);
}

#[test]
fn test_summary_format() {
    let b = CommandBatch::parse("CHECK a\nCHECK b\nADD v0.1.0 \"x\"");
    let s = b.summary();
    assert!(s.contains("CHECK"));
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_self_host.rs âˆ‡âˆ‡âˆ‡
// tests/integration_self_host.rs
#[test] fn test_warden_passes_own_rules() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ integration_skeleton.rs âˆ‡âˆ‡âˆ‡
// tests/integration_skeleton.rs
use std::path::Path;
use warden_core::skeleton;

#[test]
fn test_clean_rust_basic() {
    let code = "fn main() {\n    println!(\"hi\");\n}";
    let result = skeleton::clean(Path::new("test.rs"), code);
    assert!(result.contains("{ ... }") || result.contains("fn main"));
}

#[test]
fn test_clean_rust_nested() {
    let code = "fn outer() {\n    fn inner() { 42 }\n    inner()\n}";
    let result = skeleton::clean(Path::new("test.rs"), code);
    assert!(result.contains("fn outer") || result.contains("{ ... }"));
}

#[test]
fn test_clean_rust_impl() {
    let code = "impl Foo {\n    fn bar(&self) { 42 }\n}";
    let result = skeleton::clean(Path::new("test.rs"), code);
    assert!(result.contains("impl") || result.contains("Foo"));
}

#[test]
fn test_clean_python() {
    let code = "def hello():\n    print('hi')\n";
    let result = skeleton::clean(Path::new("test.py"), code);
    assert!(result.contains("def hello") || result.contains("..."));
}

#[test]
fn test_clean_typescript() {
    let code = "function hello() {\n    console.log('hi');\n}";
    let result = skeleton::clean(Path::new("test.ts"), code);
    assert!(result.contains("function hello") || result.contains("{ ... }"));
}

#[test]
fn test_clean_unsupported_extension() {
    let code = "some random text";
    let result = skeleton::clean(Path::new("test.xyz"), code);
    assert_eq!(result, code);
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ protection_roadmap.rs âˆ‡âˆ‡âˆ‡
use std::collections::HashMap;
use warden_core::apply::types::{ApplyOutcome, ManifestEntry, Operation, FileContent};
use warden_core::apply::validator;

#[test]
fn test_roadmap_rewrite_is_blocked() {
    let manifest = vec![ManifestEntry {
        path: "ROADMAP.md".to_string(),
        operation: Operation::Update,
    }];
    
    let mut extracted = HashMap::new();
    extracted.insert("ROADMAP.md".to_string(), FileContent {
        content: "# New Roadmap".to_string(),
        line_count: 1,
    });

    let outcome = validator::validate(&manifest, &extracted);

    match outcome {
        ApplyOutcome::ValidationFailure { errors, ai_message, .. } => {
            // It might be a "PROTECTED" error (if diff fails/file missing) 
            // OR a "Roadmap rewrite converted" error (if diff succeeds).
            // Since this test runs in isolation without a real file on disk,
            // handle_roadmap_rewrite likely returns None (file not found),
            // falling back to the standard PROTECTED error.
            
            let has_protected = errors.iter().any(|e| e.contains("PROTECTED"));
            let has_converted = errors.iter().any(|e| e.contains("Roadmap rewrite converted"));
            
            assert!(
                has_protected || has_converted,
                "Expected roadmap block, got errors: {errors:?}\nMessage: {ai_message}"
            );
        }
        _ => panic!("Should have failed validation"),
    }
}

#[test]
fn test_roadmap_rewrite_blocked_case_insensitive() {
    let manifest = vec![ManifestEntry {
        path: "roadmap.md".to_string(),
        operation: Operation::Update,
    }];
    
    let mut extracted = HashMap::new();
    extracted.insert("roadmap.md".to_string(), FileContent {
        content: "# New Roadmap".to_string(),
        line_count: 1,
    });

    let outcome = validator::validate(&manifest, &extracted);

    if let ApplyOutcome::ValidationFailure { errors, .. } = outcome {
        assert!(errors.iter().any(|e| e.contains("PROTECTED") || e.contains("Roadmap rewrite converted")));
    } else {
        panic!("Should have failed validation");
    }
}

#[test]
fn test_roadmap_error_suggests_command() {
    let manifest = vec![ManifestEntry {
        path: "ROADMAP.md".to_string(),
        operation: Operation::Update,
    }];
    
    let mut extracted = HashMap::new();
    extracted.insert("ROADMAP.md".to_string(), FileContent {
        content: "# New Roadmap".to_string(),
        line_count: 1,
    });

    let outcome = validator::validate(&manifest, &extracted);

    if let ApplyOutcome::ValidationFailure { errors, .. } = outcome {
         // The error message itself suggests using commands
         assert!(errors.iter().any(|e| e.contains("warden roadmap apply") || e.contains("Roadmap rewrite converted")));
    } else {
        panic!("Should have failed validation");
    }
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ security_validation.rs âˆ‡âˆ‡âˆ‡
// tests/security_validation.rs
use std::collections::HashMap;
use warden_core::apply::types::{ApplyOutcome, FileContent};
use warden_core::apply::validator;

fn check(path: &str) -> bool {
    let mut files = HashMap::new();
    files.insert(path.into(), FileContent { content: "x".into(), line_count: 1 });
    matches!(validator::validate(&vec![], &files), ApplyOutcome::ValidationFailure { .. })
}

#[test]
fn test_traversal_blocked() { assert!(check("../etc/passwd")); }
#[test]
fn test_absolute_paths_blocked() { assert!(check("/etc/passwd")); }
#[test]
fn test_sensitive_paths_blocked() { assert!(check(".env")); }
#[test]
fn test_valid_paths_allowed() { assert!(!check("src/main.rs")); }

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_analysis.rs âˆ‡âˆ‡âˆ‡
// tests/unit_analysis.rs - Stub (features not yet implemented)
#[test] fn test_js_complexity() {}
#[test] fn test_python_complexity() {}
#[test] fn test_snake_case_words() {}
#[test] fn test_camel_case_words() {}
#[test] fn test_warden_ignore_hash() {}
#[test] fn test_warden_ignore_html() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_audit.rs âˆ‡âˆ‡âˆ‡
// tests/unit_audit.rs
use warden_core::roadmap::audit::{scan, AuditOptions, ViolationReason};
use warden_core::roadmap::types::{Roadmap, Task, TaskStatus};
use std::fs;
use tempfile::tempdir;

fn make_task(id: &str, tests: Vec<String>) -> Task {
    Task {
        id: id.into(),
        path: format!("section/{id}"),
        text: format!("Task {id}"),
        status: TaskStatus::Complete,
        indent: 0,
        line: 0,
        children: vec![],
        tests,
    }
}

fn make_roadmap(tasks: Vec<Task>) -> Roadmap {
    // For unit tests we just need the tasks
    // In a real scenario we'd build the full tree, but scan() uses all_tasks()
    // Since we can't easily inject into all_tasks() without building Sections,
    // we have to build a Section.
    use warden_core::roadmap::types::Section;
    
    let section = Section {
        id: "main".into(),
        heading: "Main".into(),
        level: 2,
        theme: None,
        tasks,
        subsections: vec![],
        raw_content: String::new(),
        line_start: 0,
        line_end: 0,
    };
    
    Roadmap {
        path: None,
        title: "Test Roadmap".into(),
        sections: vec![section],
        raw: String::new(),
    }
}

#[test]
fn test_missing_file_detection() {
    let dir = tempdir().unwrap();
    let root = dir.path();
    
    let task = make_task("t1", vec!["missing_file.rs".into()]);
    let roadmap = make_roadmap(vec![task]);
    let opts = AuditOptions { strict: true };

    let report = scan(&roadmap, root, &opts);
    
    assert_eq!(report.violations.len(), 1);
    match &report.violations[0].reason {
        ViolationReason::MissingTestFile(f) => assert_eq!(f, "missing_file.rs"),
        _ => panic!("Wrong violation type"),
    }
}

#[test]
fn test_missing_function_detection() {
    let dir = tempdir().unwrap();
    let root = dir.path();
    
    // Create the file but NOT the function
    let file_path = root.join("tests/my_test.rs");
    fs::create_dir_all(file_path.parent().unwrap()).unwrap();
    fs::write(&file_path, "fn other_function() {}").unwrap();
    
    let task = make_task("t2", vec!["tests/my_test.rs::target_function".into()]);
    let roadmap = make_roadmap(vec![task]);
    let opts = AuditOptions { strict: true };

    let report = scan(&roadmap, root, &opts);
    
    assert_eq!(report.violations.len(), 1);
    match &report.violations[0].reason {
        ViolationReason::MissingTestFunction { file, function } => {
            assert_eq!(file, "tests/my_test.rs");
            assert_eq!(function, "target_function");
        }
        _ => panic!("Wrong violation type"),
    }
}

#[test]
fn test_successful_verification() {
    let dir = tempdir().unwrap();
    let root = dir.path();
    
    let file_path = root.join("tests/valid_test.rs");
    fs::create_dir_all(file_path.parent().unwrap()).unwrap();
    fs::write(&file_path, "fn my_cool_test() {}").unwrap();
    
    let task = make_task("t3", vec!["tests/valid_test.rs::my_cool_test".into()]);
    let roadmap = make_roadmap(vec![task]);
    let opts = AuditOptions { strict: true };

    let report = scan(&roadmap, root, &opts);
    
    assert_eq!(report.violations.len(), 0);
    assert_eq!(report.total_checked, 1);
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_config.rs âˆ‡âˆ‡âˆ‡
// tests/unit_config.rs
use warden_core::config::Config;

#[test]
fn test_load_toml() {
    let toml = r#"
        [rules]
        max_file_tokens = 3000
        ignore_naming_on = ["foo"]
        
        [preferences]
        auto_copy = false
    "#;

    let mut config = Config::new();
    config.parse_toml(toml);

    assert_eq!(config.rules.max_file_tokens, 3000);
    assert!(config.rules.ignore_naming_on.contains(&"foo".to_string()));
    assert!(!config.preferences.auto_copy);
}

#[test]
fn test_defaults() {
    let config = Config::new();
    assert_eq!(config.rules.max_file_tokens, 2000);
    assert_eq!(config.rules.max_cyclomatic_complexity, 8);
    assert!(config.preferences.auto_copy);
}

#[test]
fn test_command_single() {
    let toml = r#"
        [commands]
        check = "cargo check"
    "#;
    let mut config = Config::new();
    config.parse_toml(toml);

    let cmds = config.commands.get("check").expect("check command missing");
    assert_eq!(cmds.len(), 1);
    assert_eq!(cmds[0], "cargo check");
}

#[test]
fn test_command_list() {
    let toml = r#"
        [commands]
        check = ["cargo fmt", "cargo test"]
    "#;
    let mut config = Config::new();
    config.parse_toml(toml);

    let cmds = config.commands.get("check").expect("check command missing");
    assert_eq!(cmds.len(), 2);
    assert_eq!(cmds[0], "cargo fmt");
    assert_eq!(cmds[1], "cargo test");
}

#[test]
fn test_wardenignore() {
    let mut config = Config::new();
    
    // Should be ignored
    config.process_ignore_line("target");
    // Warden uses Regex for ignore patterns, not globs.
    // ".*\.log" matches any characters followed by .log
    config.process_ignore_line(r".*\.log");
    
    // Should be skipped
    config.process_ignore_line("# comment");
    config.process_ignore_line("");

    assert!(config.exclude_patterns.iter().any(|r| r.is_match("target")));
    assert!(config.exclude_patterns.iter().any(|r| r.is_match("app.log")));
    assert!(!config.exclude_patterns.iter().any(|r| r.is_match("src")));
}

#[test]
fn test_ignore_tokens_on() {
    // Default includes "lock" and "README.md"
    let config = Config::new();
    let rules = config.rules;

    let is_ignored = |path: &str| rules.ignore_tokens_on.iter().any(|p| path.contains(p));

    assert!(is_ignored("Cargo.lock"));
    assert!(is_ignored("README.md"));
    assert!(!is_ignored("src/main.rs"));
}

#[test]
fn test_ignore_naming_on() {
    let toml = r#"
        [rules]
        ignore_naming_on = ["tests", "spec"]
    "#;
    let mut config = Config::new();
    config.parse_toml(toml);
    
    let is_ignored = |path: &str| config.rules.ignore_naming_on.iter().any(|p| path.contains(p));

    assert!(is_ignored("tests/my_test.rs"));
    assert!(is_ignored("src/spec.rs"));
    assert!(!is_ignored("src/main.rs"));
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_diff.rs âˆ‡âˆ‡âˆ‡
//! Unit tests for roadmap diff engine.
//!
//! These tests verify the "Wicked Smart" diff algorithm correctly infers
//! user intent when comparing two roadmap versions, generating atomic
//! commands rather than destructive rewrites.

use warden_core::roadmap::{diff, Roadmap};

/// Verifies that when a task's text changes but the test anchor remains,
/// the diff engine generates an UPDATE command instead of DELETE + ADD.
///
/// This is the core "anchor-based matching" behavior that enables
/// accurate intent detection.
#[test]
fn test_text_change_is_update() {
    let current = r#"# Roadmap

## Features

- [x] **Old descriptive text** <!-- test: tests/feature.rs::test_my_feature -->
"#;

    let incoming = r#"# Roadmap

## Features

- [x] **New improved text** <!-- test: tests/feature.rs::test_my_feature -->
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    // Should have exactly one UPDATE, not DELETE + ADD
    let updates: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Update { .. }))
        .collect();

    let deletes: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Delete { .. }))
        .collect();

    let adds: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Add { .. }))
        .collect();

    assert_eq!(
        updates.len(),
        1,
        "Expected 1 UPDATE command, got {}: {:?}",
        updates.len(),
        commands
    );
    assert_eq!(
        deletes.len(),
        0,
        "Expected 0 DELETE commands, got {}: {:?}",
        deletes.len(),
        commands
    );
    assert_eq!(
        adds.len(),
        0,
        "Expected 0 ADD commands, got {}: {:?}",
        adds.len(),
        commands
    );

    // Verify the UPDATE has correct content
    if let warden_core::roadmap::Command::Update { path, text } = &updates[0] {
        assert!(
            path.contains("test-my-feature"),
            "UPDATE path should reference test-my-feature, got: {}",
            path
        );
        assert_eq!(
            text, "New improved text",
            "UPDATE text should be the new text"
        );
    }
}

/// Verifies that status changes are detected as CHECK/UNCHECK commands.
#[test]
fn test_status_change_detected() {
    let current = r#"# Roadmap

## Features

- [ ] **Pending task** <!-- test: tests/feature.rs::test_pending -->
- [x] **Complete task** <!-- test: tests/feature.rs::test_complete -->
"#;

    let incoming = r#"# Roadmap

## Features

- [x] **Pending task** <!-- test: tests/feature.rs::test_pending -->
- [ ] **Complete task** <!-- test: tests/feature.rs::test_complete -->
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    let checks: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Check { .. }))
        .collect();

    let unchecks: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Uncheck { .. }))
        .collect();

    assert_eq!(checks.len(), 1, "Expected 1 CHECK command");
    assert_eq!(unchecks.len(), 1, "Expected 1 UNCHECK command");
}

/// Verifies that deleted tasks generate DELETE commands.
#[test]
fn test_deleted_task_detected() {
    let current = r#"# Roadmap

## Features

- [x] **Keep this** <!-- test: tests/a.rs::test_keep -->
- [x] **Delete this** <!-- test: tests/b.rs::test_delete -->
"#;

    let incoming = r#"# Roadmap

## Features

- [x] **Keep this** <!-- test: tests/a.rs::test_keep -->
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    let deletes: Vec<_> = commands
        .iter()
        .filter_map(|c| {
            if let warden_core::roadmap::Command::Delete { path } = c {
                Some(path.as_str())
            } else {
                None
            }
        })
        .collect();

    assert_eq!(deletes.len(), 1, "Expected 1 DELETE command");
    assert!(
        deletes[0].contains("test-delete"),
        "DELETE should target test-delete, got: {}",
        deletes[0]
    );
}

/// Verifies that new tasks generate ADD commands.
#[test]
fn test_new_task_detected() {
    let current = r#"# Roadmap

## Features

- [x] **Existing** <!-- test: tests/a.rs::test_existing -->
"#;

    let incoming = r#"# Roadmap

## Features

- [x] **Existing** <!-- test: tests/a.rs::test_existing -->
- [ ] **Brand new task** <!-- test: tests/b.rs::test_new -->
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    let adds: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Add { .. }))
        .collect();

    assert_eq!(adds.len(), 1, "Expected 1 ADD command");
}

/// Verifies that tasks moved between sections generate MOVE commands.
#[test]
fn test_moved_task_detected() {
    let current = r#"# Roadmap

## Section A

- [x] **Mobile task** <!-- test: tests/x.rs::test_mobile -->

## Section B

"#;

    let incoming = r#"# Roadmap

## Section A

## Section B

- [x] **Mobile task** <!-- test: tests/x.rs::test_mobile -->
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    let moves: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::Move { .. }))
        .collect();

    assert_eq!(moves.len(), 1, "Expected 1 MOVE command");
}

/// Verifies that new sections generate SECTION commands.
#[test]
fn test_new_section_detected() {
    let current = r#"# Roadmap

## Existing Section

- [x] **Task** <!-- test: tests/a.rs::test_a -->
"#;

    let incoming = r#"# Roadmap

## Existing Section

- [x] **Task** <!-- test: tests/a.rs::test_a -->

## Brand New Section

- [ ] **New task**
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    let sections: Vec<_> = commands
        .iter()
        .filter(|c| matches!(c, warden_core::roadmap::Command::AddSection { .. }))
        .collect();

    assert_eq!(sections.len(), 1, "Expected 1 SECTION command");
}

/// Verifies that DELETE commands never have empty paths.
/// This was a critical bug that caused invalid command generation.
#[test]
fn test_no_empty_delete_paths() {
    let current = r#"# Roadmap

## Section

- [x] **Valid task** <!-- test: tests/a.rs::test_valid -->
- [x] **Another valid** <!-- test: tests/b.rs::test_another -->
"#;

    let incoming = r#"# Roadmap

## Section

"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    for cmd in &commands {
        if let warden_core::roadmap::Command::Delete { path } = cmd {
            assert!(
                !path.is_empty(),
                "DELETE command has empty path: {:?}",
                cmd
            );
        }
    }
}

/// Verifies combined operations: text change + status change on same task.
#[test]
fn test_combined_update_and_status_change() {
    let current = r#"# Roadmap

## Features

- [ ] **Old text** <!-- test: tests/x.rs::test_combo -->
"#;

    let incoming = r#"# Roadmap

## Features

- [x] **New text** <!-- test: tests/x.rs::test_combo -->
"#;

    let curr_roadmap = Roadmap::parse(current);
    let inc_roadmap = Roadmap::parse(incoming);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    let has_check = commands
        .iter()
        .any(|c| matches!(c, warden_core::roadmap::Command::Check { .. }));

    let has_update = commands
        .iter()
        .any(|c| matches!(c, warden_core::roadmap::Command::Update { .. }));

    assert!(has_check, "Expected CHECK command for status change");
    assert!(has_update, "Expected UPDATE command for text change");
}

/// Verifies no commands generated when roadmaps are identical.
#[test]
fn test_identical_roadmaps_no_commands() {
    let content = r#"# Roadmap

## Features

- [x] **Task one** <!-- test: tests/a.rs::test_one -->
- [ ] **Task two** <!-- test: tests/b.rs::test_two -->
"#;

    let curr_roadmap = Roadmap::parse(content);
    let inc_roadmap = Roadmap::parse(content);

    let commands = diff::diff(&curr_roadmap, &inc_roadmap);

    assert!(
        commands.is_empty(),
        "Identical roadmaps should produce no commands, got: {:?}",
        commands
    );
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_extractor.rs âˆ‡âˆ‡âˆ‡
// tests/unit_extractor.rs
use warden_core::apply::extractor;

#[test]
fn test_malformed_block_skipped() {
    let input = "âˆ‡âˆ‡âˆ‡ broken\nno footer here";
    let _ = extractor::extract_files(input);
}

#[test]
fn test_content_preserved_exactly() {
    let input = "âˆ‡âˆ‡âˆ‡ a.rs âˆ‡âˆ‡âˆ‡\nfn a() {}\nâˆ†âˆ†âˆ†";
    let files = extractor::extract_files(input).unwrap();
    assert!(files.get("a.rs").unwrap().content.contains("fn a()"));
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_manifest.rs âˆ‡âˆ‡âˆ‡
// tests/unit_manifest.rs
use warden_core::apply::manifest;

#[test]
fn test_parse_manifest() {
    let input = "âˆ‡âˆ‡âˆ‡ MANIFEST âˆ‡âˆ‡âˆ‡\na.rs\nb.rs [NEW]\nâˆ†âˆ†âˆ†";
    let m = manifest::parse_manifest(input).unwrap();
    assert!(m.is_some());
}

#[test]
fn test_new_marker() {
    let input = "âˆ‡âˆ‡âˆ‡ MANIFEST âˆ‡âˆ‡âˆ‡\na.rs [NEW]\nâˆ†âˆ†âˆ†";
    let m = manifest::parse_manifest(input).unwrap().unwrap();
    assert!(m.iter().any(|e| e.operation == warden_core::apply::types::Operation::New));
}

#[test]
fn test_delete_marker() {
    let input = "âˆ‡âˆ‡âˆ‡ MANIFEST âˆ‡âˆ‡âˆ‡\na.rs [DELETE]\nâˆ†âˆ†âˆ†";
    let m = manifest::parse_manifest(input).unwrap().unwrap();
    assert!(m.iter().any(|e| e.operation == warden_core::apply::types::Operation::Delete));
}

#[test]
fn test_default_update() {
    let input = "âˆ‡âˆ‡âˆ‡ MANIFEST âˆ‡âˆ‡âˆ‡\na.rs\nâˆ†âˆ†âˆ†";
    let m = manifest::parse_manifest(input).unwrap().unwrap();
    assert!(m.iter().any(|e| e.operation == warden_core::apply::types::Operation::Update));
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_pack.rs âˆ‡âˆ‡âˆ‡
// tests/unit_pack.rs - Stub
#[test] fn test_token_count_shown() {}
#[test] fn test_writes_context_file() {}
#[test] fn test_stdout_option() {}
#[test] fn test_copy_option() {}
#[test] fn test_noprompt() {}
#[test] fn test_git_only() {}
#[test] fn test_no_git() {}
#[test] fn test_code_only() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_pack_violations.rs âˆ‡âˆ‡âˆ‡
// tests/unit_pack_violations.rs - Stub
#[test] fn test_violations_injected() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_parser.rs âˆ‡âˆ‡âˆ‡
//! Unit tests for roadmap parser hardening.
//!
//! These tests verify critical safety features:
//! - Empty task IDs are rejected (prevents DELETE "" commands)
//! - Colliding task IDs are deduplicated (prevents UNCHECK ambiguity)
//! - Test anchors are used as stable IDs (enables UPDATE detection)

use warden_core::roadmap::Roadmap;

/// Verifies that tasks with no extractable text (empty after slugification)
/// are skipped entirely rather than creating tasks with empty IDs.
///
/// This prevents the diff engine from generating invalid `DELETE ""` commands.
#[test]
fn test_empty_id_skipped() {
    let content = r#"# Test Roadmap

## Section

- [x] **<!-- test: some/path.rs::test_func -->**
- [x] **   ** <!-- test: another/path.rs::test_func2 -->
- [x] **Valid task here** <!-- test: valid/path.rs::test_valid -->
"#;

    let roadmap = Roadmap::parse(content);
    let tasks = roadmap.all_tasks();

    // Should only have tasks with valid IDs
    for task in &tasks {
        assert!(
            !task.id.is_empty(),
            "Found task with empty ID: {:?}",
            task
        );
    }

    // The valid task should be present (anchor-based ID)
    assert!(
        tasks.iter().any(|t| t.id == "test-valid"),
        "Valid task not found. Tasks: {:?}",
        tasks.iter().map(|t| &t.id).collect::<Vec<_>>()
    );
}

/// Verifies that multiple tasks with the same slugified text
/// receive unique IDs via numeric suffixes.
///
/// Example: "Pattern: // ...", "Pattern: /* ... */" both slugify to "pattern"
/// but should become "pattern" and "pattern-1".
#[test]
fn test_id_collision_resolved() {
    let content = r#"# Test Roadmap

## Patterns

- [x] **Pattern: first**
- [x] **Pattern: second**
- [x] **Pattern: third**
- [ ] **Different task**
"#;

    let roadmap = Roadmap::parse(content);
    let tasks = roadmap.all_tasks();

    // Collect all IDs
    let ids: Vec<&str> = tasks.iter().map(|t| t.id.as_str()).collect();

    // Should have pattern, pattern-1, pattern-2 (not three "pattern"s)
    assert!(ids.contains(&"pattern-first"), "Missing pattern-first");
    assert!(ids.contains(&"pattern-second"), "Missing pattern-second");
    assert!(ids.contains(&"pattern-third"), "Missing pattern-third");
    assert!(ids.contains(&"different-task"), "Missing different-task");

    // Verify all IDs are unique
    let mut sorted = ids.clone();
    sorted.sort();
    sorted.dedup();
    assert_eq!(
        ids.len(),
        sorted.len(),
        "Duplicate IDs found: {:?}",
        ids
    );
}

/// Verifies that when a task has a test anchor, the test function name
/// is used as the task ID instead of the slugified text.
///
/// This enables the diff engine to detect text renames as UPDATE operations
/// rather than DELETE + ADD.
#[test]
fn test_anchor_id_extraction() {
    let content = r#"# Test Roadmap

## Features

- [x] **Some descriptive text here** <!-- test: tests/integration.rs::test_my_feature -->
- [x] **Another feature** <!-- test: tests/unit.rs::test_another_thing -->
- [ ] **No anchor task**
"#;

    let roadmap = Roadmap::parse(content);
    let tasks = roadmap.all_tasks();

    // Tasks with anchors should use the function name as ID
    let feature_task = tasks.iter().find(|t| t.text.contains("descriptive"));
    assert!(
        feature_task.is_some(),
        "Could not find task with 'descriptive' in text"
    );
    assert_eq!(
        feature_task.map(|t| t.id.as_str()),
        Some("test-my-feature"),
        "Anchor-based ID not extracted correctly"
    );

    let another_task = tasks.iter().find(|t| t.text.contains("Another"));
    assert_eq!(
        another_task.map(|t| t.id.as_str()),
        Some("test-another-thing"),
        "Second anchor-based ID not extracted correctly"
    );

    // Task without anchor falls back to slugified text
    let no_anchor = tasks.iter().find(|t| t.text.contains("No anchor"));
    assert_eq!(
        no_anchor.map(|t| t.id.as_str()),
        Some("no-anchor-task"),
        "Fallback slugification failed"
    );
}

/// Verifies that the full test path is parsed but only the function name
/// is used for the ID (not the full path).
#[test]
fn test_anchor_extracts_function_name_only() {
    let content = r#"# Roadmap

## Section

- [x] **Task** <!-- test: tests/very/deep/nested/path.rs::test_the_function -->
"#;

    let roadmap = Roadmap::parse(content);
    let tasks = roadmap.all_tasks();

    assert_eq!(tasks.len(), 1);
    assert_eq!(tasks[0].id, "test-the-function");
    assert_eq!(
        tasks[0].tests.first().map(String::as_str),
        Some("tests/very/deep/nested/path.rs::test_the_function")
    );
}

/// Verifies that anchor-based IDs also get deduplicated if multiple tasks
/// reference the same test function (edge case but possible).
#[test]
fn test_anchor_collision_deduplicated() {
    let content = r#"# Roadmap

## Section

- [x] **First mention** <!-- test: tests/foo.rs::test_shared -->
- [x] **Second mention** <!-- test: tests/bar.rs::test_shared -->
"#;

    let roadmap = Roadmap::parse(content);
    let tasks = roadmap.all_tasks();

    let ids: Vec<&str> = tasks.iter().map(|t| t.id.as_str()).collect();

    // Both extract to "test-shared" but should be deduplicated
    assert!(ids.contains(&"test-shared"), "Missing test-shared");
    assert!(ids.contains(&"test-shared-1"), "Missing test-shared-1");
}

/// Verifies correct handling of tasks with [no-test] marker.
/// These should fall back to text-based slugification.
#[test]
fn test_no_test_marker_uses_text_id() {
    let content = r#"# Roadmap

## Section

- [x] **Documentation site** [no-test]
- [x] **Logo and branding** [no-test]
"#;

    let roadmap = Roadmap::parse(content);
    let tasks = roadmap.all_tasks();

    let ids: Vec<&str> = tasks.iter().map(|t| t.id.as_str()).collect();

    assert!(ids.contains(&"documentation-site-no-test"));
    assert!(ids.contains(&"logo-and-branding-no-test"));
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_project.rs âˆ‡âˆ‡âˆ‡
// tests/unit_project.rs
use std::fs::File;
use tempfile::TempDir;
use warden_core::project::ProjectType;

#[test]
fn test_detect_rust() {
    let temp = TempDir::new().unwrap();
    File::create(temp.path().join("Cargo.toml")).unwrap();
    assert_eq!(ProjectType::detect_in(temp.path()), ProjectType::Rust);
}

#[test]
fn test_detect_node() {
    let temp = TempDir::new().unwrap();
    File::create(temp.path().join("package.json")).unwrap();
    assert_eq!(ProjectType::detect_in(temp.path()), ProjectType::Node);
}

#[test]
fn test_detect_python() {
    let temp = TempDir::new().unwrap();
    File::create(temp.path().join("requirements.txt")).unwrap();
    assert_eq!(ProjectType::detect_in(temp.path()), ProjectType::Python);
}

#[test]
fn test_detect_go() {
    let temp = TempDir::new().unwrap();
    File::create(temp.path().join("go.mod")).unwrap();
    assert_eq!(ProjectType::detect_in(temp.path()), ProjectType::Go);
}

#[test]
fn test_detect_unknown() {
    let temp = TempDir::new().unwrap();
    assert_eq!(ProjectType::detect_in(temp.path()), ProjectType::Unknown);
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_roadmap.rs âˆ‡âˆ‡âˆ‡
// tests/unit_roadmap.rs
use warden_core::roadmap::{CommandBatch, Roadmap};

#[test]
fn test_anchor_extraction() {
    let content = "# P\n\n## v0.1.0\n\n- [x] **F** <!-- test: tests/u.rs::test_f -->\n";
    let r = Roadmap::parse(content);
    let t = r.all_tasks();
    if let Some(task) = t.first() {
        assert!(!task.tests.is_empty());
    }
}

#[test]
fn test_delete_command() {
    let b = CommandBatch::parse("DELETE old-task");
    assert_eq!(b.commands.len(), 1);
}

#[test]
fn test_update_command() {
    let b = CommandBatch::parse("UPDATE task \"New text\"");
    assert_eq!(b.commands.len(), 1);
}

#[test]
fn test_note_command() {
    let b = CommandBatch::parse("NOTE task \"A note\"");
    assert_eq!(b.commands.len(), 1);
}

#[test]
fn test_move_command() {
    let b = CommandBatch::parse("MOVE task-a AFTER task-b");
    assert_eq!(b.commands.len(), 1);
}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_tokens.rs âˆ‡âˆ‡âˆ‡
// tests/unit_tokens.rs
use warden_core::tokens::Tokenizer;

#[test]
fn test_tokenizer_available() {
    // Basic sanity check that the tokenizer loaded (cl100k_base)
    assert!(Tokenizer::is_available());
}

#[test]
fn test_count_basic() {
    // "hello world" is typically 2 tokens in cl100k_base [15339, 1917]
    let count = Tokenizer::count("hello world");
    assert_eq!(count, 2);
    
    // Empty string should be 0
    assert_eq!(Tokenizer::count(""), 0);
}

#[test]
fn test_exceeds_limit() {
    let text = "hello world"; // 2 tokens
    
    // Limit 10 (pass)
    assert!(!Tokenizer::exceeds_limit(text, 10));
    
    // Limit 1 (fail)
    assert!(Tokenizer::exceeds_limit(text, 1));
    
    // Limit 2 (pass - strictly greater than check)
    assert!(!Tokenizer::exceeds_limit(text, 2));
}

#[test]
fn test_fallback_returns_zero() {
    // This tests the contract that if the tokenizer encounters issues 
    // (or implies empty/invalid state), it returns 0 safe-defaults.
    // Real initialization failure is hard to mock without dependency injection,
    // so we verify the empty string case as the proxy for "safe zero return".
    assert_eq!(Tokenizer::count(""), 0);
    
    // If the tokenizer were unavailable, count() returns 0.
    if !Tokenizer::is_available() {
        assert_eq!(Tokenizer::count("test content"), 0);
    }
}
âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_validator.rs âˆ‡âˆ‡âˆ‡
// tests/unit_validator.rs
use std::collections::HashMap;
use warden_core::apply::types::{ApplyOutcome, FileContent};
use warden_core::apply::validator;

fn check_content(content: &str) -> bool {
    let mut files = HashMap::new();
    files.insert("test.rs".into(), FileContent { content: content.into(), line_count: 1 });
    matches!(validator::validate(&vec![], &files), ApplyOutcome::ValidationFailure { .. })
}

#[test] fn test_block_comment_ellipsis() { assert!(check_content("/* ... */")); }
#[test] fn test_hash_ellipsis() { assert!(check_content("# ...")); }
#[test] fn test_lazy_phrase_rest_of() { assert!(check_content("// rest of implementation")); }
#[test] fn test_lazy_phrase_remaining() { assert!(check_content("// remaining code")); }
#[test] fn test_valid_code_passes() { assert!(!check_content("fn main() {}")); }
#[test] fn test_ellipsis_in_string_allowed() { assert!(!check_content("let s = \"Loading...\";")); }
#[test] fn test_warden_ignore_inline() { assert!(!check_content("// ... warden:ignore")); }
#[test] fn test_line_number_reported() {}
#[test] fn test_gnupg_blocked() {}
#[test] fn test_id_rsa_blocked() {}
#[test] fn test_credentials_blocked() {}
#[test] fn test_backup_dir_blocked() {}

âˆ†âˆ†âˆ†

âˆ‡âˆ‡âˆ‡ unit_writer.rs âˆ‡âˆ‡âˆ‡
// tests/unit_writer.rs
use std::fs;

#[test]
fn test_creates_parent_dirs() {
    let d = tempfile::tempdir().unwrap();
    let p = d.path().join("a/b/c.txt");
    fs::create_dir_all(p.parent().unwrap()).unwrap();
    fs::write(&p, "test").unwrap();
    assert!(p.exists());
}

#[test]
fn test_writes_content() {
    let d = tempfile::tempdir().unwrap();
    let p = d.path().join("test.txt");
    fs::write(&p, "hello").unwrap();
    assert_eq!(fs::read_to_string(&p).unwrap(), "hello");
}

#[test]
fn test_delete_file() {
    let d = tempfile::tempdir().unwrap();
    let p = d.path().join("test.txt");
    fs::write(&p, "x").unwrap();
    fs::remove_file(&p).unwrap();
    assert!(!p.exists());
}

#[test] fn test_tracks_written() {}

âˆ†âˆ†âˆ†


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END CODEBASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WARDEN CONSTRAINTS:
â–¡ Files < 2000 tokens
â–¡ Complexity â‰¤ 8
â–¡ Nesting â‰¤ 3
â–¡ Args â‰¤ 5
â–¡ No .unwrap() or .expect()
â–¡ Use Nabla Format (âˆ‡âˆ‡âˆ‡ ... âˆ†âˆ†âˆ†)
